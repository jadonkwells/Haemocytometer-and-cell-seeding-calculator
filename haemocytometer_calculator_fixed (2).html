<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Haemocytometer Cell Count & Plate Seeding</title>

  <!-- Optional: Bootstrap for LabArchives-like form spacing/appearance -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

  <style>
    /* Baseline layout */
    body { background:#f8fafc; font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif; }
    .page { max-width: 900px; margin: 0 auto; padding: 24px clamp(16px,4vw,32px); }
    .widget-bg { background:#ffffff; border:1px solid #e5e7eb; border-radius:16px; padding:20px; box-shadow:0 1px 2px rgba(0,0,0,.04); }
    h2.title { margin-top: 0; }

    /* Make LabArchives-like classes render nicely */
    .user-input { border: 1px solid #e5e7eb; border-radius: 12px; padding: 10px 12px; background: #fff; }
    .user-input:focus { outline: none; border-color:#93c5fd; box-shadow: 0 0 0 3px rgba(147,197,253,.35); }
    .form-label { color:#475569; }
    .d-none { display: none !important; }

    /* Results card and grid — from your snippet */
    .result-card{
      background:#f3f6f8; border:1px solid #d5dee6; border-radius:16px;
      padding:16px; box-shadow:0 2px 8px rgba(0,0,0,0.06); margin-top:8px;
    }
    .result-grid{ display:grid; grid-template-columns:1fr 1fr; gap:12px 16px; }
    .result-item{ display:flex; flex-direction:column; }
    .result-item.wide{ grid-column:1 / -1; }
    .result-item label{ font-size:0.9rem; color:#465a6e; margin-bottom:6px; }
    .result-value{
      font-size:1.3rem; font-weight:700; padding:10px 12px;
      border:1px solid #c9d4de; border-radius:10px; background:#fff; text-align:right;
    }
    .accent-green{ background:#eef9f1; border-color:#cfe9d7; }
    .accent-red{ background:#ffecec; border-color:#f4b5b5; }
    .invalid{ border-color:#e55353 !important; box-shadow:0 0 0 2px rgba(229,83,83,0.15); }
    .instruction-box{
      background:#fff9db; border:1px solid #f0e2a3; border-radius:12px;
      padding:12px 14px; font-size:1.05rem; line-height:1.35;
    }
    @media (max-width:700px){ .result-grid{ grid-template-columns:1fr; } }
  </style>
</head>
<body>

<!-- ===== High-level modes ===== -->
<!--
  Use Bootstrap grid to lay out the two high-level selectors.  We wrap the
  content in a widget-bg container and constrain its width to 700px to
  align with the main widget.  The co‑culture toggle has been removed
  entirely.  Styles are applied via Bootstrap classes for consistency.
-->
<div id="highLevelModes" class="widget-bg mb-3" style="max-width:700px; margin: 12px auto;">
  <div class="row g-3">
    <div class="col-md-6">
      <label class="form-label" for="measurementMode">How will you provide concentration?</label>
      <select id="measurementMode" class="form-select">
        <option value="haem">I'm using a haemocytometer</option>
        <option value="stock">I already know my stock concentration</option>
      </select>
    </div>
    <div class="col-md-6">
      <label class="form-label" for="purposeMode">What are you doing?</label>
      <select id="purposeMode" class="form-select">
        <option value="seeding">I'm seeding plates</option>
        <option value="freezing">I'm freezing down vials</option>
      </select>
    </div>
  </div>
</div>

<!-- Stock-only input (visible when measurementMode=stock) -->
<!--
  Constrain the stock panel to the same width as the main widget and
  center it within the page.  This ensures consistent alignment when
  toggled into view.
-->
<div id="stockOnlyPanel" class="widget-bg d-none" style="max-width:700px; margin:12px auto;">
  <div class="mb-3">
    <label class="form-label" for="knownStockConc">Stock concentration (cells/mL)</label>
    <input id="knownStockConc" type="number" min="0" step="1" placeholder="e.g. 1200000" class="user-input w-100">
  </div>
</div>

<!-- Freezing panel (visible when purposeMode=freezing) -->
<!--
  Constrain the freezing panel to the same width as the main widget and
  center it within the page for consistent layout.
-->
<div id="freezingPanel" class="widget-bg d-none" style="max-width:700px; margin:12px auto;">
  <div class="row g-3">
    <div class="col-md-4">
      <label class="form-label" for="cellsPerVial">Cells per vial</label>
      <input id="cellsPerVial" type="number" min="1" step="1" placeholder="e.g. 1000000" class="user-input w-100">
    </div>
    <div class="col-md-4">
      <label class="form-label" for="volPerVialMl">Volume per vial (mL)</label>
      <input id="volPerVialMl" type="number" min="0.1" step="0.1" placeholder="e.g. 1.0" class="user-input w-100">
    </div>
    <div class="col-md-4">
      <label class="form-label" for="minVials">Minimum vials (optional)</label>
      <input id="minVials" type="number" min="1" step="1" placeholder="Leave blank" class="user-input w-100">
    </div>
  </div>
  <div class="mt-2" style="font-size:13px; color:#666;">Freezing mode calculates vials needed from total cells (incl. overage) and outputs per‑vial + total volumes.</div>
</div>

<!-- Co-culture panel removed: keep empty container to satisfy script references. -->
<div id="coCulturePanel" style="display:none;"></div>

  <main class="page">

    <!-- ======= YOUR WIDGET MARKUP (unchanged) ======= -->
    <div class="widget-bg" style="max-width: 700px">
      <h2 class="title mb-3">Haemocytometer Cell Count & Plate Seeding</h2>

      <!-- Step 1 — Haemocytometer -->
      <div id="haemSection">
      <div class="mb-3">
        <label class="form-label" for="totalCount">Total Cell Count</label>
        <input class="user-input w-100" id="totalCount" name="totalCount" type="number" min="0">
      </div>

      <div class="mb-3">
        <label class="form-label" for="squares">How many squares counted?</label>
        <select class="user-input w-100" id="squares" name="squares">
          <option>1</option><option>2</option><option>3</option>
          <option selected>4</option><option>5</option><option>6</option>
          <option>7</option><option>8</option><option>9</option>
        </select>
      </div>

      <div class="mb-3">
        <label class="form-label" for="dilution">Dilution Factor (1:x)</label>
        <input class="user-input w-100" id="dilution" name="dilution" type="number" min="1" step="1" value="5">
      </div>

      </div>
      <!-- Step 2 — Seeding -->
      <div class="mb-3">
        <label class="form-label" for="plate">Plate Type</label>
        <select class="user-input w-100" id="plate" name="plate">
          <option value="96" selected>96-well</option>
          <option value="48">48-well</option>
          <option value="24">24-well</option>
          <option value="12">12-well</option>
          <option value="6">6-well</option>
        </select>
      </div>

      <div class="mb-3">
        <label class="form-label" for="mode">Seeding Mode</label>
        <select class="user-input w-100" id="mode" name="mode">
          <option value="cells" selected>Target concentration (Cells/well)</option>
          <option value="conf">% Confluence</option>
        </select>
      </div>

      <div class="mb-3" id="targetCellDiv">
        <label class="form-label" for="targetCells">Target concentration (Cells/well)</label>
        <input class="user-input w-100" id="targetCells" name="targetCells" type="number" min="1">
      </div>

      <div class="mb-3 d-none" id="confDiv">
        <label class="form-label" for="targetConf">Target % Confluence</label>
        <input class="user-input w-100" id="targetConf" name="targetConf" type="number" min="1" max="100">
        <label class="form-label mt-2" for="baseline">OPTIONAL: Specify number of cells/well at 100% confluence:</label>
        <input class="user-input w-100" id="baseline" name="baseline" type="number" min="1">
      </div>

      <div class="mb-3">
        <label class="form-label">Calculate number of wells by:</label>
        <select class="user-input w-100" id="wellMode" name="wellMode">
          <option value="manual" selected>Manual entry</option>
          <option value="plates">Whole plates</option>
          <option value="grid">Columns × Rows</option>
        </select>
      </div>

      <!-- plates mode -->
      <div class="mb-3 d-none" id="plateCountDiv">
        <label class="form-label" for="numPlates">Number of plates (Use 0.5 for half plate)</label>
        <input class="user-input w-100" id="numPlates" name="numPlates" type="number" min="0.5" step="0.5">
        <label class="form-label mt-2">PBS Border?</label>
        <select class="user-input w-100" id="pbsBorder" name="pbsBorder">
          <option value="yes">Yes</option>
          <option value="no" selected>No</option>
        </select>
      </div>

      <!-- manual mode -->
      <div class="mb-3" id="manualWellDiv">
        <label class="form-label" for="numWells">Number of wells (1–96)</label>
        <input class="user-input w-100" id="numWells" name="numWells" type="number" min="1" max="96">
        <label class="form-label mt-2" for="numManualPlates">How many replicate plates?</label>
        <input class="user-input w-100" id="numManualPlates" name="numManualPlates" type="number" min="1" value="1">
      </div>

      <!-- grid mode -->
      <div class="mb-3 d-none" id="gridDiv">
        <label class="form-label" for="numCols">Columns</label>
        <input class="user-input w-100" id="numCols" name="numCols" type="number" min="1" max="12">
        <label class="form-label mt-2" for="numRows">Rows</label>
        <input class="user-input w-100" id="numRows" name="numRows" type="number" min="1" max="8">
        <label class="form-label mt-2" for="numGridPlates">How many replicate plates?</label>
        <input class="user-input w-100" id="numGridPlates" name="numGridPlates" type="number" min="1" value="1">
      </div>

      <div class="mb-3">
        <label class="form-label" id="volLabel" for="mediaPerWell">Target volume per Well (µL)</label>
        <input class="user-input w-100" id="mediaPerWell" name="mediaPerWell" type="number" min="1">
      </div>

      <div class="mb-3">
        <label class="form-label" for="overage">% extra volume</label>
        <input class="user-input w-100" id="overage" name="overage" type="number" min="0" value="10">
      </div>

      <div class="mb-3">
        <label class="form-label" for="optimise">Optimise for:</label>
        <select class="user-input w-100" id="optimise" name="optimise">
          <option value="least" selected>Least amount of cells required</option>
          <option value="easy">Ease of dilution</option>
        </select>
      </div>

      <!-- Results Card -->
      <h3 class="subheading">Results</h3>
      <div class="result-card" id="resultCard">
        <div class="result-grid">

          <!-- Haemocytometer output (two boxes) -->
          <div class="result-item">
            <label>Average (cells per square)</label>
            <input id="outAvgSq" name="outAvgSq" class="result-value" type="text" readonly>
          </div>
          <div class="result-item">
            <label>Concentration (cells per mL)</label>
            <input id="outConc" name="outConc" class="result-value" type="text" readonly>
          </div>

          <div class="result-item">
            <label>Number of wells to seed</label>
            <input id="outWells" name="outWells" class="result-value" type="text" readonly>
          </div>
          <div class="result-item">
            <label>Cells per well</label>
            <input id="outCellsPerWell" name="outCellsPerWell" class="result-value" type="text" readonly>
          </div>
          <div class="result-item">
            <label>Total cells needed</label>
            <input id="outTotalCells" name="outTotalCells" class="result-value" type="text" readonly>
          </div>
          <div class="result-item">
            <label>(<span id="extraPct">10</span>% extra)</label>
            <input id="outOverCells" name="outOverCells" class="result-value" type="text" readonly>
          </div>

          <!-- Green full-width -->
          <div class="result-item wide">
            <label>Volume of original cell suspension (<span id="origUnit">xL</span>)</label>
            <input id="outOrigVol" name="outOrigVol" class="result-value accent-green" type="text" readonly>
          </div>
          <!-- Red full-width -->
          <div class="result-item wide">
            <label>Volume of Media (diluent) (<span id="mediaUnit">xL</span>)</label>
            <input id="outMediaVol" name="outMediaVol" class="result-value accent-red" type="text" readonly>
          </div>

          <div class="result-item">
            <label>Required concentration</label>
            <input id="outReqConc" name="outReqConc" class="result-value" type="text" readonly>
          </div>
          <div class="result-item">
            <label>Final volume (xL)</label>
            <input id="outMixTotal" name="outMixTotal" class="result-value" type="text" readonly>
          </div>

          <!-- Instruction statement -->
          <div class="result-item wide">
            <div id="instructionBox" class="instruction-box"></div>
          </div>
        </div>
      </div>
    </div>
    
<div id="recordSection" style="margin: 16px auto; max-width: 900px;">
  <div style="display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin:8px 0;">
    <button id="saveCountBtn" type="button" style="padding:8px 12px;">Save count</button>
    <button id="downloadCsvBtn" type="button" style="padding:8px 12px; display:none;">Download CSV</button>
    <button id="resetSessionBtn" type="button" style="padding:8px 12px;">Start New Session</button>
  </div>
  <div style="overflow-x:auto;">
    <table id="countsTable" style="width:100%; border-collapse: collapse; min-width:720px;">
      <thead>
        <tr>
          <th style="text-align:left; border-bottom:1px solid #ddd; padding:6px;">Count #</th>
          <th style="text-align:left; border-bottom:1px solid #ddd; padding:6px;">Avg (cells/sq)</th>
          <th style="text-align:left; border-bottom:1px solid #ddd; padding:6px;">Conc (cells/mL)</th>
          <th style="text-align:left; border-bottom:1px solid #ddd; padding:6px;">Cells/well</th>
          <th style="text-align:left; border-bottom:1px solid #ddd; padding:6px;">Cell Vol</th>
          <th style="text-align:left; border-bottom:1px solid #ddd; padding:6px;">Media Vol</th>
          <th style="text-align:left; border-bottom:1px solid #ddd; padding:6px;">Final Vol</th>
          <th style="text-align:left; border-bottom:1px solid #ddd; padding:6px;">Req Conc</th>
        </tr>
      </thead>
      <tbody id="countsTableBody"></tbody>
    </table>
  </div>
</div>

<!-- ======= END WIDGET MARKUP ======= -->

  </main>

  <!-- Optional: Bootstrap JS bundle (only needed if using interactive Bootstrap components) -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

  <script>
    // ===== Minimal LabArchives shim so your script runs standalone =====
    const LA_PARENT_CLASS_SHIM = {
      init: function(){ /* no-op */ },
      to_json: function(){ return {}; },
      from_json: function(){},
      test_data: function(){ return {}; },
      is_valid: function(){ return true; },
      is_edited: function(){ return true; },
      reset_edited: function(){}
    };

    // ===== Your original script (verbatim) =====
    var my_widget_script = {
      CORNING_BASELINE: { "96": 32000, "48": 50000, "24": 190000, "12": 380000, "6": 600000 },
      PLATE_GEOM:       { "96": [8,12], "48": [6,8], "24": [4,6],  "12": [3,4],   "6": [2,3] },
      DEFAULT_VOL:      { "96": 0.100, "48": 0.250, "24": 0.500, "12": 1.000, "6": 2.000 }, // mL

      parent_class: LA_PARENT_CLASS_SHIM, // attach shim

      init: function (mode, json_data) {
        const $ = (id) => document.getElementById(id);
        const nz = (v, d=0) => { const n = parseFloat(v); return isNaN(n) ? d : n; };
        const clamp = (v, min, max) => Math.min(Math.max(v, min), max);
        const roundMl2 = (ml) => Math.round(ml*100)/100;
        const fmtVol = (ml) => (ml < 1 ? Math.round(ml*1000)+' µL' : roundMl2(ml).toFixed(2)+' mL');
        const unitOf = (ml) => (ml < 1 ? 'µL' : 'mL');

        const plateCapacity = (plate) => parseInt(plate,10) || 96;
        const plateGeom     = (plate) => this.PLATE_GEOM[plate] || [8,12];

        // Labels / defaults / constraints
        const updateVolLabel = () => {
          const plate = $('plate')?.value || '96';
          const isMl = (plate === '12' || plate === '6');
          if ($('volLabel')) $('volLabel').textContent = 'Target volume per Well (' + (isMl ? 'mL' : 'µL') + ')';
        };
        const setDefaultVolumeForPlate = () => {
          const plate = $('plate')?.value || '96';
          const ml = this.DEFAULT_VOL[plate] || 0.100;
          const input = $('mediaPerWell'); if (!input) return;
          if (plate === '12' || plate === '6') { input.min='0.1'; input.value = ml.toFixed(2); }
          else { input.min='1'; input.value = Math.round(ml*1000); }
          updateVolLabel();
        };
        const updateCapacityConstraints = () => {
          const plate = $('plate')?.value || '96';
          const cap = plateCapacity(plate);
          const [rowsMax, colsMax] = plateGeom(plate);
          if ($('numWells')) $('numWells').max = String(cap);
          if ($('numCols'))  $('numCols').max  = String(colsMax);
          if ($('numRows'))  $('numRows').max  = String(rowsMax);
          const colsLab = document.querySelector('label[for="numCols"]');
          const rowsLab = document.querySelector('label[for="numRows"]');
          if (colsLab) colsLab.textContent = 'Columns (1–' + colsMax + ')';
          if (rowsLab) rowsLab.textContent = 'Rows (1–' + rowsMax + ')';
        };
        const updateVisibility = () => {
          const modeSel  = $('mode')?.value || 'cells';
          const wellMode = $('wellMode')?.value || 'manual';
          $('targetCellDiv')?.classList.toggle('d-none', modeSel !== 'cells');
          $('confDiv')?.classList.toggle('d-none',    modeSel !== 'conf');
          $('plateCountDiv')?.classList.toggle('d-none', wellMode !== 'plates');
          $('manualWellDiv')?.classList.toggle('d-none', wellMode !== 'manual');
          $('gridDiv')?.classList.toggle('d-none',     wellMode !== 'grid');
          updateVolLabel();
          updateCapacityConstraints();
        };

        // Wells math
        const wellsPerPlateInterior = (plate) => {
          const [r,c] = plateGeom(plate);
          return Math.max(r-2,0) * Math.max(c-2,0);
        };
        const wellsPerPlateTotal = (plate) => plateCapacity(plate);
        const totalWells = () => {
          const wm = $('wellMode')?.value || 'manual';
          if (wm === 'manual') {
            const wells = clamp(nz($('numWells')?.value, 0), 1, plateCapacity($('plate')?.value||'96'));
            const reps  = Math.max(1, nz($('numManualPlates')?.value, 1));
            return wells * reps;
          }
          if (wm === 'grid') {
            const plate = $('plate')?.value || '96';
            const [rowsMax, colsMax] = plateGeom(plate);
            const c = clamp(nz($('numCols')?.value, 0), 1, colsMax);
            const r = clamp(nz($('numRows')?.value, 0), 1, rowsMax);
            const p = Math.max(1, nz($('numGridPlates')?.value, 1));
            return c*r*p;
          }
          const plate = $('plate')?.value || '96';
          const pbs   = ($('pbsBorder')?.value || 'no') === 'yes';
          const per   = pbs ? wellsPerPlateInterior(plate) : wellsPerPlateTotal(plate);
          const plates = Math.max(0.5, nz($('numPlates')?.value, 0));
          return per * plates;
        };

        // Targets
        const baselineCells = () => {
          const manual = nz($('baseline')?.value, NaN);
          if (!isNaN(manual) && manual > 0) return manual;
          return my_widget_script.CORNING_BASELINE[$('plate')?.value || '96'] || 0;
        };
        const targetCellsPerWell = () => {
          if (($('mode')?.value || 'cells') === 'cells') return Math.max(1, nz($('targetCells')?.value, 0));
          const pct = clamp(nz($('targetConf')?.value, 0), 1, 100);
          return baselineCells() * (pct/100);
        };

        // Haemocytometer outputs
        const cellsPerMlFromCounting = () => {
          const total   = Math.max(0, nz($('totalCount')?.value));
          const squares = clamp(nz($('squares')?.value, 4), 1, 9);
          const dil     = Math.max(1, nz($('dilution')?.value, 5));
          const avg     = total / squares;
          const cMl     = avg / 0.0001 * dil;
          $('outAvgSq').value = avg ? avg.toFixed(2) : '';
          $('outConc').value  = cMl ? Math.round(cMl).toLocaleString() + ' cells/mL' : '';
          return { avg, cMl };
        };

        // “Pipettable” rounding
        const roundFinalVolume = (ml) => {
          const mode = $('optimise')?.value || 'least';
          if (ml < 1) {
            const step = (mode === 'easy') ? 0.050 : 0.010;   // 50 µL or 10 µL
            return Math.max(step, Math.round(ml/step)*step);
          } else {
            const step = (mode === 'easy') ? 0.5 : 0.1;       // 0.5 mL or 0.1 mL
            return Math.max(step, Math.round(ml/step)*step);
          }
        };

        // Validation
        const requiredIds = () => {
          const ids = ['totalCount','squares','dilution','plate','mediaPerWell','overage','optimise'];
          if (($('mode')?.value || 'cells') === 'cells') ids.push('targetCells'); else ids.push('targetConf');
          const wm = $('wellMode')?.value || 'manual';
          if (wm === 'manual') ids.push('numWells','numManualPlates');
          if (wm === 'plates') ids.push('numPlates','pbsBorder');
          if (wm === 'grid')   ids.push('numCols','numRows','numGridPlates');
          return ids;
        };
        const isFilledValid = (id) => {
          const el = $(id); if (!el) return true;
          const v = el.value?.trim(); if (!v) return false;
          const n = parseFloat(v);
          const plate = $('plate')?.value || '96';
          const [rowsMax, colsMax] = plateGeom(plate);
          if (id === 'numWells') return n>=1 && n<=plateCapacity(plate);
          if (id === 'numManualPlates') return n>=1;
          if (id === 'numCols') return n>=1 && n<=colsMax;
          if (id === 'numRows') return n>=1 && n<=rowsMax;
          if (id === 'numGridPlates') return n>=1;
          if (id === 'targetConf') return n>=1 && n<=100;
          if (id === 'dilution') return n>=1;
          if (id === 'mediaPerWell') {
            const isMl = (plate === '12' || plate === '6');
            return n >= (isMl ? 0.1 : 1);
          }
          // Treat non-numeric select fields as valid. 'optimise' is a select
          // field whose value cannot be parsed to a number.
          return n > 0 || id === 'pbsBorder' || id === 'plate' || id === 'optimise';
        };
        const clearOutputs = () => {
          ['outAvgSq','outConc','outWells','outCellsPerWell','outTotalCells','outOverCells',
           'outOrigVol','outReqConc','outMixTotal','outMediaVol'
          ].forEach(id=>{ const el = $(id); if(el) el.value=''; });
          const ib = $('instructionBox'); if (ib) ib.textContent = '';
        };
        const validate = () => {
          let ok = true;
          document.querySelectorAll('.invalid').forEach(e=>e.classList.remove('invalid'));
          requiredIds().forEach(id=>{
            if (!isFilledValid(id)) { ok=false; $(id)?.classList.add('invalid'); }
          });
          if (!ok) clearOutputs();
          return ok;
        };

        // Main calc
        const recalc = () => {
          if (!validate()) return;

          const { cMl } = cellsPerMlFromCounting();
          const wells       = Math.round(totalWells());
          const targetPerW  = targetCellsPerWell();
          const overPct     = Math.max(0, nz($('overage')?.value, 10));
          if ($('extraPct')) $('extraPct').textContent = String(overPct);

          const plate       = $('plate')?.value || '96';
          const isMlInput   = (plate === '12' || plate === '6');
          const rawVol      = nz($('mediaPerWell')?.value, 0);
          const perWellMl   = isMlInput ? rawVol : (rawVol / 1000);

          const totalCells     = targetPerW * wells;
          const totalCellsOver = totalCells * (1 + overPct/100);

          const stockVolMlRaw  = cMl > 0 ? totalCellsOver / cMl : 0;

          const reqMixConc     = perWellMl > 0 ? (targetPerW / perWellMl) : 0;
          // Calculate the base final mix volume using the user-provided overage percentage rather than a fixed 10%.
          const baseFinalMl    = perWellMl * wells * (1 + overPct/100);
          const finalMixMl     = roundFinalVolume(baseFinalMl);

          const stockInMixMl   = cMl > 0 ? (reqMixConc / cMl) * finalMixMl : 0;
          const mediaMl        = Math.max(0, finalMixMl - stockInMixMl);

          if ($('origUnit'))  $('origUnit').textContent  = unitOf(stockVolMlRaw);
          if ($('mediaUnit')) $('mediaUnit').textContent = unitOf(mediaMl);

          $('outWells').value        = wells.toString();
          $('outCellsPerWell').value = Math.round(targetPerW).toLocaleString() + ' cells';
          $('outTotalCells').value   = Math.round(totalCells).toLocaleString();
          $('outOverCells').value    = Math.round(totalCellsOver).toLocaleString();
          $('outOrigVol').value      = fmtVol(stockVolMlRaw);
          $('outReqConc').value      = Math.round(reqMixConc).toLocaleString() + ' cells/mL';
          $('outMixTotal').value     = fmtVol(finalMixMl);
          $('outMediaVol').value     = fmtVol(mediaMl);

          const perWellText = fmtVol(perWellMl);
          const mode = ($('mode')?.value || 'cells');
          const tail = (mode === 'cells')
            ? (perWellText + ' per well of plate for ' + Math.round(targetPerW).toLocaleString() + ' cells/well at seeding.')
            : (perWellText + ' per well of plate for ' + clamp(nz($('targetConf')?.value, 0),1,100) + '% confluency at seeding.');
          const instruction = 'Take ' + fmtVol(stockInMixMl) +
            ' of cell suspension and dilute in ' + fmtVol(mediaMl) +
            ' of Media to a final concentration of ' +
            Math.round(reqMixConc).toLocaleString() + ' cells/mL. Add ' + tail;
          const ib = $('instructionBox'); if (ib) ib.textContent = instruction;
        };

        // Plate change → defaults + constraints + (optional) baseline fill
        if ($('plate')) {
          $('plate').addEventListener('change', () => {
            setDefaultVolumeForPlate();
            updateCapacityConstraints();
            if ($('baseline') && !$('baseline').value) {
              const v = my_widget_script.CORNING_BASELINE[$('plate').value] || '';
              if (v) $('baseline').value = v;
            }
            validate(); recalc();
          });
          setDefaultVolumeForPlate();
          updateCapacityConstraints();
        }

        // Bind toggles + inputs
        ['mode','wellMode','optimise'].forEach(id=>{
          const el=$(id); if(el) el.addEventListener('change', ()=>{updateVisibility(); validate(); recalc();});
        });
        [
          'totalCount','squares','dilution','plate','mode',
          'targetCells','targetConf','baseline',
          'wellMode','numPlates','pbsBorder',
          'numWells','numManualPlates',
          'numCols','numRows','numGridPlates',
          'mediaPerWell','overage','optimise'
        ].forEach(id=>{
          const el = $(id);
          if (el) {
            el.addEventListener('input', ()=>{ validate(); recalc(); });
            el.addEventListener('change', ()=>{ validate(); recalc(); });
          }
        });

        updateVisibility();
        validate();
        // Perform an initial calculation once all defaults are set so that
        // the results populate as soon as all required fields are present.
        recalc();
        this.parent_class.init(mode, json_data, this);
      },

      to_json: function(){ return this.parent_class.to_json(); },
      from_json: function(d){ this.parent_class.from_json(d); },
      test_data: function(){ return this.parent_class.test_data(); },
      is_valid: function(b){ return this.parent_class.is_valid(b); },
      is_edited: function(){ return this.parent_class.is_edited(); },
      reset_edited: function(){ return this.parent_class.reset_edited(); }
    };

    // Boot the widget once the DOM is ready
    window.addEventListener('DOMContentLoaded', function(){
      my_widget_script.init('standalone', {});
    });
  </script>

<script>
(function(){
  const $ = (id)=>document.getElementById(id);
  const qs = (sel)=>document.querySelector(sel);
  const qsa = (sel)=>Array.from(document.querySelectorAll(sel));
  const nz = (v, d)=> (v===''||v===null||v===undefined||isNaN(v)) ? d : Number(v);

  // ----- Helpers -----
  const unitOf = (ml)=> (ml < 1 ? 'µL' : 'mL');
  const fmtVol = (ml)=> (ml < 1 ? Math.round(ml*1000) + ' µL' : ml.toFixed(2) + ' mL');
  const parseVolToMl = (s)=>{
    if (!s) return 0;
    const n = parseFloat(String(s).replace(/[^0-9.]/g,'')) || 0;
    return /µl|µL/.test(String(s)) ? (n/1000) : n;
  };

  // Move Required conc + Final volume above green/red
  function moveResultsOrder(){
    const req = $('outReqConc')?.closest('.result-item');
    const fin = $('outMixTotal')?.closest('.result-item');
    const green = $('outOrigVol')?.closest('.result-item');
    const red = $('outMediaVol')?.closest('.result-item');
    const grid = req?.parentElement || fin?.parentElement || green?.parentElement;
    if (grid && req && fin && green && red){
      grid.insertBefore(req, green);
      grid.insertBefore(fin, green);
    }
  }

  // Baseline placeholder (use default if empty)
  function setBaselinePlaceholder(){
    const plate = $('plate')?.value || '96';
    const def = (window.my_widget_script && window.my_widget_script.CORNING_BASELINE) ? (window.my_widget_script.CORNING_BASELINE[plate]||'') : '';
    const el = $('baseline'); if (el) el.placeholder = def ? ('Default for ' + plate + '-well plate is ' + def) : '';
  }
  function patchBaselineCells(){
    if (typeof window.baselineCells === 'function' && !window.baselineCells._patched){
      const orig = window.baselineCells;
      window.baselineCells = function(){
        const v = (document.getElementById('baseline')?.value || '').trim();
        if (v !== '') return orig();
        const plate = document.getElementById('plate')?.value || '96';
        const def = (window.my_widget_script && window.my_widget_script.CORNING_BASELINE) ? (window.my_widget_script.CORNING_BASELINE[plate]||0) : 0;
        return def ? Number(def) : 0;
      };
      window.baselineCells._patched = true;
    }
  }

  // Snap number of plates to nearest 0.5
  function wireNumPlatesSnap(){
    const np = $('numPlates');
    if (np && !np._rounded){
      np.setAttribute('step','0.5');
      np.addEventListener('blur', ()=>{
        const v = parseFloat(np.value);
        if (!isNaN(v)){
          const snapped = Math.max(0.5, Math.round(v*2)/2);
          np.value = snapped.toFixed(1);
          try { if (typeof validate==='function') validate(); } catch(_){}
          try { if (typeof recalc==='function') recalc(); } catch(_){}
        }
      });
      np._rounded = true;
    }
  }

  // Ease-of-dilution scaler (applies in standard seeding flow)
  function applyEaseScaling(){
    const opt = ($('optimise')?.value || 'least');
    const isCo = $('coCultureToggle')?.checked === true;
    const purpose = $('purposeMode')?.value || 'seeding';
    if (opt !== 'easy' || isCo || purpose === 'freezing') return false;

    const stockMl = parseVolToMl($('outOrigVol')?.value || '');
    const mediaMl = parseVolToMl($('outMediaVol')?.value || '');
    if (!(stockMl > 0 && mediaMl >= 0)) return false;

    const step = (mediaMl < 1 ? 0.050 : 0.5);
    const targetMedia = Math.ceil(mediaMl / step) * step;
    const scale = (mediaMl > 0) ? (targetMedia / mediaMl) : 1;
    const newMedia = targetMedia;
    const newStock = stockMl * scale;
    const newTotal = newMedia + newStock;

    if ($('origUnit'))  $('origUnit').textContent  = unitOf(newStock);
    if ($('mediaUnit')) $('mediaUnit').textContent = unitOf(newMedia);
    if ($('outMixTotal')) $('outMixTotal').value = fmtVol(newTotal);
    if ($('outOrigVol'))  $('outOrigVol').value  = fmtVol(newStock);
    if ($('outMediaVol')) $('outMediaVol').value = fmtVol(newMedia);

    const reqText = $('outReqConc')?.value || (Math.round(parseFloat((($('outReqConc')?.value||'').replace(/[^0-9.]/g,''))||0)).toLocaleString() + ' cells/mL');
    const perWellUl = parseFloat($('mediaPerWell')?.value || '0') || 0;
    const plate = $('plate')?.value || '96';
    const perWellMl = (plate==='12'||plate==='6') ? perWellUl : perWellUl/1000;
    const mode = ($('mode')?.value || 'cells');
    const targetPerW = parseFloat((($('outCellsPerWell')?.value || '0').toString()).replace(/[^0-9.]/g,'')) || 0;
    const tail = (mode === 'cells')
      ? (fmtVol(perWellMl) + ' per well for ' + (Math.round(targetPerW).toLocaleString()) + ' cells/well at seeding.')
      : (fmtVol(perWellMl) + ' per well for ' + (Math.max(1, Math.min(100, parseFloat($('targetConf')?.value || '0') || 0))) + '% confluency at seeding.');
    const ib = $('instructionBox');
    if (ib){
      ib.innerHTML = 'Take <strong>' + fmtVol(newStock) + '</strong> of cell suspension and dilute in <strong>' +
                     fmtVol(newMedia) + '</strong> of Media to a final volume of <strong>' + fmtVol(newTotal) +
                     '</strong> (' + (reqText.replace(/[^0-9, ]/g,'').trim() || reqText) + '). Add ' + tail;
    }
    return true;
  }

  // UI toggling and co-culture table
  function addLineRow(name='', target='', conc=''){
    const tb = $('coTbody'); if(!tb) return;
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td style="padding:6px;"><input type="text" class="co-name" placeholder="e.g. A375" value="${name}" style="width:100%; padding:6px;"></td>
      <td style="padding:6px;"><input type="number" class="co-target" min="0" step="1" placeholder="e.g. 2000" value="${target}" style="width:140px; padding:6px;"></td>
      <td style="padding:6px;"><input type="number" class="co-conc" min="0" step="1" placeholder="e.g. 1200000" value="${conc}" style="width:160px; padding:6px;"></td>
      <td style="padding:6px;"><button type="button" class="co-del" style="padding:4px 8px;">Remove</button></td>
    `;
    tb.appendChild(tr);
  }
  function readCoLines(){
    return qsa('#coTbody tr').map(tr=>{
      const name = tr.querySelector('.co-name')?.value || '';
      const tgt  = parseFloat(tr.querySelector('.co-target')?.value || '0') || 0;
      const conc = parseFloat(tr.querySelector('.co-conc')?.value || '0') || 0;
      return {name, tgt, conc};
    }).filter(r=> r.tgt>0 && r.conc>0);
  }
  function wireModeUI(){
    const mm = $('measurementMode'), pm = $('purposeMode'), cc = $('coCultureToggle');
    function sync(){
      const isStock = (mm?.value === 'stock');
      const isFreezing = (pm?.value === 'freezing');
      const isCo = (cc?.checked === true);

      $('haemSection')?.classList.toggle('d-none', isStock);
      const avgItem = $('outAvgSq')?.closest('.result-item');
      if (avgItem) avgItem.classList.toggle('d-none', isStock);

      $('stockOnlyPanel')?.classList.toggle('d-none', !isStock);
      $('freezingPanel')?.classList.toggle('d-none', !isFreezing);
      $('coCulturePanel')?.classList.toggle('d-none', !isCo);

      ['plate','mode','wellMode','mediaPerWell','overage','optimise'].forEach(id=>{
        const grp = $(id)?.closest('.mb-3');
        if (grp) grp.classList.toggle('d-none', isFreezing);
      });
      ['targetCellDiv','confDiv','plateCountDiv','manualWellDiv','gridDiv'].forEach(id=>{
        const el = $(id);
        if (el) el.classList.toggle('d-none', isFreezing);
      });

      try{ if (typeof validate==='function') validate(); }catch(_){}
      try{ if (typeof recalc==='function') recalc(); }catch(_){}
    }
    mm?.addEventListener('change', sync);
    pm?.addEventListener('change', sync);
    cc?.addEventListener('change', sync);
    $('addLineBtn')?.addEventListener('click', ()=> addLineRow());
    $('clearLinesBtn')?.addEventListener('click', ()=>{ const tb=$('coTbody'); if(tb) tb.innerHTML=''; try{recalc();}catch(_){}});
    document.addEventListener('click', (e)=>{
      if (e.target && e.target.classList.contains('co-del')){
        e.target.closest('tr')?.remove();
        try{ recalc(); }catch(_){}
      }
    });
    cc?.addEventListener('change', ()=>{ if (cc.checked && $('coTbody').children.length===0) addLineRow(); });
    sync();
  }

  // Patch recalc to support stock mode, freezing mode, and co-culture path; then apply ease scaling for standard mode
  function patchRecalc(){
    if (typeof window.recalc !== 'function') return;
    const orig = window.recalc;
    window.recalc = function(){
      const mmode = $('measurementMode')?.value || 'haem';
      const purpose = $('purposeMode')?.value || 'seeding';
      const isCo = $('coCultureToggle')?.checked === true;

      // Co-culture mastermix path
      if (isCo){
        // Compute per-well volumes for each line and diluent
        const lines = readCoLines();
        const perWellUl = parseFloat($('mediaPerWell')?.value || '0') || 0;
        const plate = $('plate')?.value || '96';
        const perWellMl = (plate==='12'||plate==='6') ? perWellUl : (perWellUl/1000);
        let volStocksPerWell = 0;
        const vols = [];
        lines.forEach(r=>{
          const v = (r.tgt>0 && r.conc>0)? (r.tgt / r.conc) : 0; // mL per well
          vols.push({name:(r.name||'line'), perWellMl:v});
          volStocksPerWell += v;
        });
        const diluentPerWellMl = Math.max(0, perWellMl - volStocksPerWell);
        let wells = parseInt((($('outWells')?.value || '').toString().replace(/[^0-9]/g,'')) || '0') || parseInt($('numWells')?.value || '0') || 0;
        const totalStockMl = vols.reduce((a,v)=> a + v.perWellMl,0) * wells;
        const totalDilMl = diluentPerWellMl * wells;
        const totalMl = totalStockMl + totalDilMl;

        if ($('outOrigVol'))  $('outOrigVol').value  = fmtVol(totalStockMl);
        if ($('outMediaVol')) $('outMediaVol').value = fmtVol(totalDilMl);
        if ($('outMixTotal')) $('outMixTotal').value = fmtVol(totalMl);
        if ($('outReqConc'))  $('outReqConc').value  = ''; // n/a for mixed stocks
        if ($('origUnit'))  $('origUnit').textContent  = unitOf(totalStockMl);
        if ($('mediaUnit')) $('mediaUnit').textContent = unitOf(totalDilMl);

        const parts = vols.map(v => v.name + ': ' + (v.perWellMl<1 ? Math.round(v.perWellMl*1000)+' µL' : v.perWellMl.toFixed(2)+' mL') + '/well');
        const dilTxt = diluentPerWellMl>0 ? (diluentPerWellMl<1 ? Math.round(diluentPerWellMl*1000)+' µL' : diluentPerWellMl.toFixed(2)+' mL') + '/well' : '';
        const ib = $('instructionBox');
        if (ib){
          ib.textContent = 'Co‑culture mastermix per well → ' + parts.join(' + ') + (dilTxt ? (' + Diluent: ' + dilTxt) : '');
        }
        return;
      }

      // Run original to compute counts, wells, defaults
      try { orig(); } catch(_){}

      // Stock concentration path
      if (mmode === 'stock'){
        const known = parseFloat($('knownStockConc')?.value || '0') || 0;
        if (known > 0){
          const req = parseFloat((($('outReqConc')?.value || '').toString().replace(/[^0-9.]/g,'')) || '0') || 0;
          let finalMl = parseVolToMl($('outMixTotal')?.value || '');
          if (!(finalMl > 0)){
            const perWellUl = parseFloat($('mediaPerWell')?.value || '0') || 0;
            const plate = $('plate')?.value || '96';
            const perWellMl = (plate==='12'||plate==='6') ? perWellUl : perWellUl/1000;
            let wells = parseInt((($('outWells')?.value || '').toString().replace(/[^0-9]/g,'')) || '0') || parseInt($('numWells')?.value || '0') || 0;
            finalMl = perWellMl * wells;
          }
          let stockInMixMl = (req>0 && known>0) ? (req/known)*finalMl : 0;
          let mediaMl = Math.max(0, finalMl - stockInMixMl);

          // Apply ease scaling in stock path too
          const opt = ($('optimise')?.value || 'least');
          if (opt === 'easy' && mediaMl > 0){
            const step = (mediaMl < 1 ? 0.050 : 0.5);
            const targetMedia = Math.ceil(mediaMl / step) * step;
            const scale = targetMedia / mediaMl;
            mediaMl = targetMedia;
            stockInMixMl *= scale;
            finalMl = stockInMixMl + mediaMl;
          }

          if ($('outOrigVol'))  $('outOrigVol').value  = fmtVol(stockInMixMl);
          if ($('outMediaVol')) $('outMediaVol').value = fmtVol(mediaMl);
          if ($('outMixTotal')) $('outMixTotal').value = fmtVol(finalMl);
          if ($('origUnit'))  $('origUnit').textContent  = unitOf(stockInMixMl);
          if ($('mediaUnit')) $('mediaUnit').textContent = unitOf(mediaMl);

          const ib = $('instructionBox');
          if (ib){
            const reqText = Math.round(req).toLocaleString() + ' cells/mL';
            ib.innerHTML = 'Take <strong>' + fmtVol(stockInMixMl) + '</strong> of cell suspension and dilute in <strong>' +
                           fmtVol(mediaMl) + '</strong> of Media to a final volume of <strong>' + fmtVol(finalMl) +
                           '</strong> (' + reqText + '). Add ' + fmtVol(finalMl) + ' total mix split per your per‑well volume.';
          }
          // Ensure displayed concentration matches known
          if ($('outConc')) $('outConc').value = Math.round(known).toLocaleString() + ' cells/mL';
          return;
        }
      }

      // Freezing mode
      if (purpose === 'freezing'){
        const totalCells = parseFloat((($('outOverCells')?.value || $('outTotalCells')?.value || '0').toString()).replace(/[^0-9.]/g,'')) || 0;
        const cellsPerVial = parseFloat($('cellsPerVial')?.value || '0') || 0;
        const volPerVialMl = parseFloat($('volPerVialMl')?.value || '0') || 0;
        const minVials = parseInt($('minVials')?.value || '0') || 0;
        if (cellsPerVial>0 && volPerVialMl>0){
          let vials = Math.ceil(totalCells / cellsPerVial);
          if (minVials>0) vials = Math.max(vials, minVials);
          let stockConc = 0;
          if (($('measurementMode')?.value || 'haem') === 'stock'){
            stockConc = parseFloat($('knownStockConc')?.value || '0') || 0;
          } else {
            stockConc = parseFloat((($('outConc')?.value || '').toString()).replace(/[^0-9.]/g,'')) || 0;
          }
          const cellVolPerVialMl = (stockConc>0) ? (cellsPerVial / stockConc) : 0;
          const mediaPerVialMl = Math.max(0, volPerVialMl - cellVolPerVialMl);
          const totalCellVolMl = cellVolPerVialMl * vials;
          const totalFreezeMediaMl = mediaPerVialMl * vials;
          if ($('outOrigVol'))  $('outOrigVol').value  = fmtVol(totalCellVolMl);
          if ($('outMediaVol')) $('outMediaVol').value = fmtVol(totalFreezeMediaMl);
          if ($('outMixTotal')) $('outMixTotal').value = fmtVol(totalCellVolMl + totalFreezeMediaMl);
          if ($('outReqConc'))  $('outReqConc').value  = '';
          const ib = $('instructionBox');
          if (ib){
            ib.textContent = 'Freeze‑down plan: ' + vials + ' vials @ ' + cellsPerVial.toLocaleString() + ' cells in ' +
                             volPerVialMl.toFixed(2) + ' mL each. Per vial: ' + fmtVol(cellVolPerVialMl) + ' cells + ' +
                             fmtVol(mediaPerVialMl) + ' freezing media. Total: ' + fmtVol(totalCellVolMl) + ' cells + ' +
                             fmtVol(totalFreezeMediaMl) + ' freezing media.';
          }
          return;
        }
      }

      // Standard seeding: after orig, apply ease scaling + unify instruction
      if (!applyEaseScaling()){
        // If ease not applied, still update instruction to match displayed volumes
        const stockMl = parseVolToMl($('outOrigVol')?.value || '');
        const mediaMl = parseVolToMl($('outMediaVol')?.value || '');
        const totalMl = stockMl + mediaMl;
        const reqText = $('outReqConc')?.value || (Math.round(parseFloat((($('outReqConc')?.value||'').replace(/[^0-9.]/g,''))||0)).toLocaleString() + ' cells/mL');
        const perWellUl = parseFloat($('mediaPerWell')?.value || '0') || 0;
        const plate = $('plate')?.value || '96';
        const perWellMl = (plate==='12'||plate==='6') ? perWellUl : perWellUl/1000;
        const mode = ($('mode')?.value || 'cells');
        const targetPerW = parseFloat((($('outCellsPerWell')?.value || '0').toString()).replace(/[^0-9.]/g,'')) || 0;
        const tail = (mode === 'cells')
          ? (fmtVol(perWellMl) + ' per well for ' + (Math.round(targetPerW).toLocaleString()) + ' cells/well at seeding.')
          : (fmtVol(perWellMl) + ' per well for ' + (Math.max(1, Math.min(100, parseFloat($('targetConf')?.value || '0') || 0))) + '% confluency at seeding.');
        const ib = $('instructionBox');
        if (ib && (stockMl>0 || mediaMl>0)){
          ib.innerHTML = 'Take <strong>' + fmtVol(stockMl) + '</strong> of cell suspension and dilute in <strong>' +
                         fmtVol(mediaMl) + '</strong> of Media to a final volume of <strong>' + fmtVol(totalMl) +
                         '</strong> (' + (reqText.replace(/[^0-9, ]/g,'').trim() || reqText) + '). Add ' + tail;
        }
      }
    };
  }

  // Save/CSV + 24h persistence (includes new fields + co-culture lines JSON)
  const INPUT_IDS = [
    'measurementMode','purposeMode','coCultureToggle','knownStockConc',
    'cellsPerVial','volPerVialMl','minVials',
    'totalCount','squares','dilution','plate','mode',
    'targetCells','targetConf','baseline',
    'wellMode','numWells','numManualPlates','numCols','numRows','numGridPlates','numPlates',
    'pbsBorder','mediaPerWell','overage','optimise'
  ];
  const OUTPUT_IDS = [
    'outAvgSq','outConc','outWells','outCellsPerWell',
    'outTotalCells','outOverCells','outReqConc',
    'outMixTotal','outOrigVol','outMediaVol'
  ];
  window.countsList = window.countsList || [];

  function collectInputs(){
    const data = {};
    INPUT_IDS.forEach(id=>{
      const el = $(id);
      if (!el) return;
      if (el.type === 'checkbox') data[id] = el.checked;
      else data[id] = el.value ?? '';
    });
    data['coLines'] = readCoLines();
    return data;
  }
  function applyInputs(data){
    if (!data) return;
    INPUT_IDS.forEach(id=>{
      const el = $(id); if (!el || data[id]===undefined) return;
      if (el.type==='checkbox') el.checked = !!data[id];
      else el.value = data[id];
    });
    if (Array.isArray(data.coLines) && $('coTbody')){
      $('coTbody').innerHTML = '';
      data.coLines.forEach(r=> addLineRow(r.name||'', r.tgt||'', r.conc||''));
    }
  }
  function renderCountsTable(){
    const tb = $('countsTableBody'); if (!tb) return;
    tb.innerHTML = '';
    window.countsList.forEach((r,i)=>{
      const tr = document.createElement('tr');
      [i+1, r.avg, r.conc, r.cellsPerWell, r.origVol, r.mediaVol, r.finalVol, r.reqConc].forEach(v=>{
        const td = document.createElement('td'); td.style.padding='6px 8px'; td.style.borderTop='1px solid #eee'; td.textContent = v || ''; tr.appendChild(td);
      });
      tb.appendChild(tr);
    });
  }
  function saveCount(){
    const row = {
      avg: $('outAvgSq')?.value || '',
      conc: $('outConc')?.value || '',
      cellsPerWell: $('outCellsPerWell')?.value || '',
      origVol: $('outOrigVol')?.value || '',
      mediaVol: $('outMediaVol')?.value || '',
      finalVol: $('outMixTotal')?.value || '',
      reqConc: $('outReqConc')?.value || ''
    };
    const snap = { timestamp: new Date().toISOString(), inputs: collectInputs() };
    OUTPUT_IDS.forEach(id=> snap[id] = $(id)?.value || '');
    snap.instruction = ($('instructionBox')?.innerText || '').trim();
    row._snapshot = snap;
    window.countsList.push(row);
    renderCountsTable();
    if ($('downloadCsvBtn')) $('downloadCsvBtn').style.display = window.countsList.length ? '' : 'none';
    try{ saveState(); }catch(_){}
  }
  function downloadCsv(){
    if (!window.countsList.length) return;
    const headers = [
      'Count #','Timestamp',
      'measurementMode','purposeMode','coCultureToggle','knownStockConc','cellsPerVial','volPerVialMl','minVials',
      'totalCount','squares','dilution','plate','mode','targetCells','targetConf','baseline',
      'wellMode','numWells','numManualPlates','numCols','numRows','numGridPlates','numPlates',
      'pbsBorder','mediaPerWell','overage','optimise',
      'outAvgSq','outConc','outWells','outCellsPerWell','outTotalCells','outOverCells','outReqConc','outMixTotal','outOrigVol','outMediaVol',
      'coCultureLines','instruction'
    ];
    let csv = headers.join(',') + '\n';
    window.countsList.forEach((r, idx)=>{
      const s = r._snapshot || {};
      const ins = s.inputs || {};
      const coJson = JSON.stringify(ins.coLines || []);
      const vals = [
        idx+1, s.timestamp || '',
        ins.measurementMode||'', ins.purposeMode||'', (ins.coCultureToggle? 'true':'false'), ins.knownStockConc||'',
        ins.cellsPerVial||'', ins.volPerVialMl||'', ins.minVials||'',
        ins.totalCount||'', ins.squares||'', ins.dilution||'', ins.plate||'', ins.mode||'',
        ins.targetCells||'', ins.targetConf||'', ins.baseline||'',
        ins.wellMode||'', ins.numWells||'', ins.numManualPlates||'', ins.numCols||'', ins.numRows||'', ins.numGridPlates||'', ins.numPlates||'',
        ins.pbsBorder||'', ins.mediaPerWell||'', ins.overage||'', ins.optimise||'',
        s.outAvgSq||'', s.outConc||'', s.outWells||'', s.outCellsPerWell||'',
        s.outTotalCells||'', s.outOverCells||'', s.outReqConc||'', s.outMixTotal||'', s.outOrigVol||'', s.outMediaVol||'',
        coJson, s.instruction||''
      ].map(v=>{
        const t = String(v == null ? '' : v).replace(/\n/g,' ');
        return (t.includes(',') || t.includes('\"')) ? '\"' + t.replace(/\"/g,'\"\"') + '\"' : t;
      });
      csv += vals.join(',') + '\n';
    });
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'cell_counts_full.csv';
    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
  }

  // Persistence with 24h TTL
  const STORAGE_KEY = 'haemo_widget_state_v4';
  const MS_TTL = 24 * 60 * 60 * 1000;
  function saveState(){
    const payload = { savedAt: Date.now(), inputs: collectInputs(), countsList: (window.countsList||[]) };
    try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(payload)); }catch(_){}
  }
  function clearState(){ try{ localStorage.removeItem(STORAGE_KEY); }catch(_){ } }
  function loadStateIfFresh(){
    const raw = localStorage.getItem(STORAGE_KEY); if(!raw) return;
    let obj=null; try{ obj=JSON.parse(raw);}catch(_){}
    if(!obj || !obj.savedAt) return;
    if(Date.now()-obj.savedAt > MS_TTL){ clearState(); return; }
    applyInputs(obj.inputs||{});
    window.countsList = Array.isArray(obj.countsList) ? obj.countsList : [];
    renderCountsTable();
    if ($('downloadCsvBtn')) $('downloadCsvBtn').style.display = window.countsList.length ? '' : 'none';
  }

  // Wire
  function init(){
    moveResultsOrder();
    setBaselinePlaceholder();
    patchBaselineCells();
    wireNumPlatesSnap();
    wireModeUI();
    patchRecalc();
    // wire record/csv/reset
    $('saveCountBtn')?.addEventListener('click', saveCount);
    $('downloadCsvBtn')?.addEventListener('click', downloadCsv);
    $('resetSessionBtn')?.addEventListener('click', ()=>{ clearState(); location.reload(); });
    // autosave
    ['input','change'].forEach(evt=> document.addEventListener(evt, (e)=>{
      const id = e?.target?.id; if (!id) return;
      if (['baseline','numPlates','numWells','mediaPerWell','optimise','knownStockConc','cellsPerVial','volPerVialMl','minVials'].includes(id)){
        try{ saveState(); }catch(_){}
      }
    }));
    // placeholder refresh
    $('plate')?.addEventListener('change', setBaselinePlaceholder);
    $('mode')?.addEventListener('change', setBaselinePlaceholder);
    // initial recalc (original may still be wiring itself)
    setTimeout(()=>{ try{ if (typeof validate==='function') validate(); }catch(_){}
                     try{ if (typeof recalc==='function') recalc(); }catch(_){}
                   }, 0);
  }
  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', init); } else { init(); }
})();
</script>

</body>
</html>
